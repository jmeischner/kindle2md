<!DOCTYPE html PUBLIC
"-//W3C//DTD XHTML 1.0 Strict//EN"
"XHTML1-s.dtd" >
<html xmlns="http://www.w3.org/TR/1999/REC-html-in-xml" xml:lang="en" lang="en">
    <head>
    <meta charset="UTF-8">
    <style>
        .bodyContainer {
            font-family: Arial, Helvetica, sans-serif;
            text-align: center;
            padding-left: 32px;
            padding-right: 32px;
        }
        
        .notebookFor {
            font-size: 18px;
            font-weight: 700;
            text-align: center;
            color: rgb(119, 119, 119);
            margin: 24px 0px 0px;
            padding: 0px;
        }
        
        .bookTitle {
            font-size: 24px;
            font-weight: 700;
            text-align: center;
            color: #333333;
            margin-top: 22px;
            padding: 0px;
        }
        
        .authors {
            font-size: 18px;
            font-weight: 700;
            text-align: center;
            color: rgb(119, 119, 119);
            margin-top: 22px;
            margin-bottom: 24px;
            padding: 0px;
        }
    
        .citation {
            font-size: 18px;
            font-weight: 500;
            text-align: center;
            color: #333333;
            margin-top: 22px;
            margin-bottom: 24px;
            padding: 0px;
        }
    
        .sectionHeading {
            font-size: 24px;
            font-weight: 700;
            text-align: left;
            color: #333333;
            margin-top: 24px;
            padding: 0px;
        }
        
        .noteHeading {
            font-size: 18px;
            font-weight: 700;
            text-align: left;
            color: #333333;
            margin-top: 20px;
            padding: 0px;
        }
        
        .noteText {
            font-size: 18px;
            font-weight: 500;
            text-align: left;
            color: #333333;
            margin: 2px 0px 0px;
            padding: 0px;
        }
        
        .highlight_blue {
            color: rgb(178, 205, 251);
        }
        
        .highlight_orange {
            color: #ffd7ae;
        }
        
        .highlight_pink {
            color: rgb(255, 191, 206);
        }
        
        .highlight_yellow {
            color: rgb(247, 206, 0);
        }
        
        .notebookGraphic {
            margin-top: 10px;
            text-align: left;
        }
        
        .notebookGraphic img {
            -o-box-shadow:      0px 0px 5px #888;
            -icab-box-shadow:   0px 0px 5px #888;
            -khtml-box-shadow:  0px 0px 5px #888;
            -moz-box-shadow:    0px 0px 5px #888;
            -webkit-box-shadow: 0px 0px 5px #888;
            box-shadow:         0px 0px 5px #888; 
            max-width: 100%;
            height: auto;
        }
        
        hr {
            border: 0px none;
            height: 1px;
            background: none repeat scroll 0% 0% rgb(221, 221, 221);
        }
        </style>
        <script>
            </script>
    </head>
    <body>
        <div class="bodyContainer">
            <div class="notebookFor">
                Notebookexport
            </div>
            <div class="bookTitle">
                Hands-On Machine Learning with Scikit-Learn, Keras & TensorFlow
            </div>
            <div class="authors">
                Aurelien Geron
            </div>
            <div class="citation">
                
            </div>
            <hr />
            <div class="sectionHeading">
    1. The Machine Learning Landscape
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - What Is Machine Learning? > Position 394
</div>
<div class="noteText">
    Machine learning is the science (and art) of programming computers so they can learn from data. Here is a slightly more general definition: [Machine learning is the] field of study that gives computers the ability to learn without being explicitly programmed.—Arthur Samuel, 1959
</div><div class="noteHeading">
    Notiz - What Is Machine Learning? > Position 399
</div>
<div class="noteText">
     Machine learning i
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - What Is Machine Learning? > Position 407
</div>
<div class="noteText">
    The part of a machine learning system that learns and makes predictions is called a model. Neural networks and random forests are examples of models.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Why Use Machine Learning? > Position 438
</div>
<div class="noteText">
    Another area where machine learning shines is for problems that either are too complex for traditional approaches or have no known algorithm. For example, consider speech recognition.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Why Use Machine Learning? > Position 452
</div>
<div class="noteText">
    To summarize, machine learning is great for: Problems for which existing solutions require a lot of fine-tuning or long lists of rules (a machine learning model can often simplify code and perform better than the traditional approach) Complex problems for which using a traditional approach yields no good solution (the best machine learning techniques can perhaps find a solution) Fluctuating environments (a machine learning system can easily be retrained on new data, always keeping it up to date) Getting insights about complex problems and large amounts of data
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Supervised learning > Position 541
</div>
<div class="noteText">
    In supervised learning, the training set you feed to the algorithm includes the desired solutions, called labels (Figure 1-5). Figure 1-5. A labeled training set for spam classification (an example of supervised learning)
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Supervised learning > Position 545
</div>
<div class="noteText">
    classification.
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Supervised learning > Position 547
</div>
<div class="noteText">
    predict a target numeric value, such as the price of a car, given a set of features (mileage, age, brand, etc.). This sort of task is called regression
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Supervised learning > Position 555
</div>
<div class="noteText">
    logistic regression is commonly used for classification, as it can output a value that corresponds to the probability of belonging to a given class (e.g., 20% chance of being spam).
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Unsupervised learning > Position 570
</div>
<div class="noteText">
    In unsupervised learning, as you might guess, the training data is unlabeled (Figure 1-7). The system tries to learn without a teacher.
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Unsupervised learning > Position 573
</div>
<div class="noteText">
    You may want to run a clustering algorithm to try to detect groups of similar visitors
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Unsupervised learning > Position 583
</div>
<div class="noteText">
    Visualization algorithms are also good examples of unsupervised learning: you feed them a lot of complex and unlabeled data, and they output a 2D or 3D representation of your data that can easily be plotted
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Unsupervised learning > Position 589
</div>
<div class="noteText">
    dimensionality reduction,
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Unsupervised learning > Position 592
</div>
<div class="noteText">
    This is called feature extraction.
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Unsupervised learning > Position 604
</div>
<div class="noteText">
    anomaly detection—
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Unsupervised learning > Position 606
</div>
<div class="noteText">
    The system is shown mostly normal instances during training, so it learns to recognize them; then, when it sees a new instance, it can tell whether it looks like a normal one or whether it is likely an anomaly
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Unsupervised learning > Position 609
</div>
<div class="noteText">
    novelty detection:
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Unsupervised learning > Position 618
</div>
<div class="noteText">
    association rule learning, in which the goal is to dig into large amounts of data and discover interesting relations between attributes.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Semi-supervised learning > Position 624
</div>
<div class="noteText">
    Some algorithms can deal with data that’s partially labeled. This is called semi-supervised learning
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Semi-supervised learning > Position 630
</div>
<div class="noteText">
    Some photo-hosting services, such as Google Photos, are good examples of this. Once you upload all your family photos to the service, it automatically recognizes that the same person A shows up in photos 1, 5, and 11, while another person B shows up in photos 2, 5, and 7. This is the unsupervised part of the algorithm (clustering). Now all the system needs is for you to tell it who these people are. Just add one label per person⁠3 and it is able to name everyone in every photo, which is useful for searching photos.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Self-supervised learning > Position 639
</div>
<div class="noteText">
    Another approach to machine learning involves actually generating a fully labeled dataset from a fully unlabeled one. Again, once the whole dataset is labeled, any supervised learning algorithm can be used. This approach is called self-supervised learning.
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Self-supervised learning > Position 641
</div>
<div class="noteText">
    For example, if you have a large dataset of unlabeled images, you can randomly mask a small part of each image and then train a model to recover the original image (Figure 1-12). During training, the masked images are used as the inputs to the model, and the original images are used as the labels. Figure 1-12. Self-supervised learning example: input (left) and target (right) The resulting model may be quite useful in itself—for example, to repair damaged images or to erase unwanted objects from pictures. But more often than not, a model trained using self-supervised learning is not the final goal. You’ll usually want to tweak and fine-tune the model for a slightly different task—one that you actually care about.
</div><div class="noteHeading">
    Markierung(<span class="highlight_orange">orange</span>) - Self-supervised learning > Position 659
</div>
<div class="noteText">
    Transferring knowledge from one task to another is called transfer learning, and it’s one of the most important techniques in machine learning today, especially when using deep neural networks (i.e., neural networks composed of many layers of neurons).
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Reinforcement learning > Position 669
</div>
<div class="noteText">
    Reinforcement learning is a very different beast. The learning system, called an agent in this context, can observe the environment, select and perform actions, and get rewards in return (or penalties in the form of negative rewards, as shown in Figure 1-13). It must then learn by itself what is the best strategy, called a policy, to get the most reward over time. A policy defines what action the agent should choose when it is in a given situation.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Batch learning > Position 688
</div>
<div class="noteText">
    In batch learning, the system is incapable of learning incrementally: it must be trained using all the available data.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Batch learning > Position 690
</div>
<div class="noteText">
    This will generally take a lot of time and computing resources, so it is typically done offline. First the system is trained, and then it is launched into production and runs without learning anymore; it just applies what it has learned. This is called offline learning.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Batch learning > Position 693
</div>
<div class="noteText">
    Unfortunately, a model’s performance tends to decay slowly over time, simply because the world continues to evolve while the model remains unchanged. This phenomenon is often called model rot or data drift.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Online learning > Position 718
</div>
<div class="noteText">
    In online learning, you train the system incrementally by feeding it data instances sequentially, either individually or in small groups called mini-batches. Each learning step is fast and cheap, so the system can learn about new data on the fly, as it arrives
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Online learning > Position 726
</div>
<div class="noteText">
    Additionally, online learning algorithms can be used to train models on huge datasets that cannot fit in one machine’s main memory (this is called out-of-core learning).
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Online learning > Position 731
</div>
<div class="noteText">
    One important parameter of online learning systems is how fast they should adapt to changing data: this is called the learning rate.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Online learning > Position 738
</div>
<div class="noteText">
    Out-of-core learning is usually done offline (i.e., not on the live system), so online learning can be a confusing name. Think of it as incremental learning.
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Online learning > Position 740
</div>
<div class="noteText">
    A big challenge with online learning is that if bad data is fed to the system, the system’s performance will decline, possibly quickly
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Instance-based learning > Position 756
</div>
<div class="noteText">
    Instead of just flagging emails that are identical to known spam emails, your spam filter could be programmed to also flag emails that are very similar to known spam emails. This requires a measure of similarity between two emails. A (very basic) similarity measure between two emails could be to count the number of words they have in common. The system would flag an email as spam if it has many words in common with a known spam email. This is called instance-based learning: the system learns the examples by heart, then generalizes to new cases by using a similarity measure to compare them to the learned examples (or a subset of them).
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Model-based learning and a typical machine learning workflow > Position 768
</div>
<div class="noteText">
    Another way to generalize from a set of examples is to build a model of these examples and then use that model to make predictions. This is called model-based learning
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Model-based learning and a typical machine learning workflow > Position 797
</div>
<div class="noteText">
    There does seem to be a trend here! Although the data is noisy (i.e., partly random), it looks like life satisfaction goes up more or less linearly as the country’s GDP per capita increases. So you decide to model life satisfaction as a linear function of GDP per capita.
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Model-based learning and a typical machine learning workflow > Position 801
</div>
<div class="noteText">
    model selection: you selected a linear model of life satisfaction with just one attribute, GDP per capita
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Model-based learning and a typical machine learning workflow > Position 811
</div>
<div class="noteText">
    Before you can use your model, you need to define the parameter values θ0 and θ1.
</div><div class="noteHeading">
    Markierung(<span class="highlight_yellow">gelb</span>) - Model-based learning and a typical machine learning workflow > Position 814
</div>
<div class="noteText">
    You can either define a utility function (or fitness function) that measures how good your model is, or you can define a cost function that measures how bad it is. For linear regression problems, people typically use a cost function that measures the distance between the linear model’s predictions and the training examples; the objective is to minimize this distance.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Model-based learning and a typical machine learning workflow > Position 818
</div>
<div class="noteText">
    This is where the linear regression algorithm comes in: you feed it your training examples, and it finds the parameters that make the linear model fit best to your data. This is called training the model. In our case, the algorithm finds that the optimal parameter values are θ0 = 3.75 and θ1 = 6.78 × 10–5.
</div><div class="noteHeading">
    Markierung(<span class="highlight_orange">orange</span>) - Model-based learning and a typical machine learning workflow > Position 824
</div>
<div class="noteText">
    Confusingly, the word “model” can refer to a type of model (e.g., linear regression), to a fully specified model architecture (e.g., linear regression with one input and one output), or to the final trained model ready to be used for predictions (e.g., linear regression with one input and one output, using θ0 = 3.75 and θ1 = 6.78 × 10–5). Model selection consists in choosing the type of model and fully specifying its architecture.
</div><div class="noteHeading">
    Markierung(<span class="highlight_orange">orange</span>) - Model-based learning and a typical machine learning workflow > Position 828
</div>
<div class="noteText">
    Training a model means running an algorithm to find the model parameters that will make it best fit the training data, and hopefully make good predictions on new data.
</div><div class="noteHeading">
    Markierung(<span class="highlight_orange">orange</span>) - Model-based learning and a typical machine learning workflow > Position 894
</div>
<div class="noteText">
    If you had used an instance-based learning algorithm instead, you would have found that Israel has the closest GDP per capita to that of Cyprus ($ 38,341), and since the OECD data tells us that Israelis’ life satisfaction is 7.2, you would have predicted a life satisfaction of 7.2 for Cyprus. If you zoom out a bit and look at the two next-closest countries, you will find Lithuania and Slovenia, both with a life satisfaction of 5.9. Averaging these three values, you get 6.33, which is pretty close to your model-based prediction. This simple algorithm is called k-nearest neighbors regression (in this example, k = 3).
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Main Challenges of Machine Learning > Position 928
</div>
<div class="noteText">
    Main Challenges of Machine Learning
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Main Challenges of Machine Learning > Position 930
</div>
<div class="noteText">
    In short, since your main task is to select a model and
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Main Challenges of Machine Learning > Position 930
</div>
<div class="noteText">
    train it on some data, the two things that can go wrong are “bad model” and “bad data”. Let’s start with examples of bad data.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Nonrepresentative Training Data > Position 972
</div>
<div class="noteText">
    if the sample is too small, you will have sampling noise (i.e., nonrepresentative data as a result of chance),
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Nonrepresentative Training Data > Position 973
</div>
<div class="noteText">
    even very large samples can be nonrepresentative if the sampling method is flawed. This is called sampling bias.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Irrelevant Features > Position 1003
</div>
<div class="noteText">
    A critical part of the success of a machine learning project is coming up with a good set of features to train on. This process, called feature engineering, involves the following steps: Feature selection (selecting the most useful features to train on among existing features) Feature extraction (combining existing features to produce a more useful one⁠—as we saw earlier, dimensionality reduction algorithms can help) Creating new features by gathering new data
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Overfitting the Training Data > Position 1017
</div>
<div class="noteText">
    In machine learning this is called overfitting: it means that the model performs well on the training data, but it does not generalize well.
</div><div class="noteHeading">
    Markierung(<span class="highlight_orange">orange</span>) - Overfitting the Training Data > Position 1031
</div>
<div class="noteText">
    Overfitting happens when the model is too complex relative to the amount and noisiness of the training data. Here are possible solutions: Simplify the model by selecting one with fewer parameters (e.g., a linear model rather than a high-degree polynomial model), by reducing the number of attributes in the training data, or by constraining the model. Gather more training data. Reduce the noise in the training data (e.g., fix data errors and remove outliers).
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Overfitting the Training Data > Position 1037
</div>
<div class="noteText">
    Constraining a model to make it simpler and reduce the risk of overfitting is called regularization.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Overfitting the Training Data > Position 1055
</div>
<div class="noteText">
    The amount of regularization to apply during learning can be controlled by a hyperparameter. A hyperparameter is a parameter of a learning algorithm (not of the model). As such, it is not affected by the learning algorithm itself; it must be set prior to training and remains constant during training.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Underfitting the Training Data > Position 1068
</div>
<div class="noteText">
    Here are the main options for fixing this problem: Select a more powerful model, with more parameters. Feed better features to the learning algorithm (feature engineering). Reduce the constraints on the model (for example by reducing the regularization hyperparameter).
</div><div class="noteHeading">
    Notiz - Underfitting the Training Data > Position 1072
</div>
<div class="noteText">
    How to work against underfitting 
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Testing and Validating > Position 1096
</div>
<div class="noteText">
    The error rate on new cases is called the generalization error (or out-of-sample error), and by evaluating your model on the test set, you get an estimate of this error. This value tells you how well your model will perform on instances it has never seen before.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Hyperparameter Tuning and Model Selection > Position 1114
</div>
<div class="noteText">
    The problem is that you measured the generalization error multiple times on the test set, and you adapted the model and hyperparameters to produce the best model for that particular set. This means the model is unlikely to perform as well on new data.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Hyperparameter Tuning and Model Selection > Position 1117
</div>
<div class="noteText">
    A common solution to this problem is called holdout validation (Figure 1-25): you simply hold out part of the training set to evaluate several candidate models and select the best one.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Hyperparameter Tuning and Model Selection > Position 1120
</div>
<div class="noteText">
    The new held-out set is called the validation set (or the development set, or dev set). More specifically, you train multiple models with various hyperparameters on the reduced training set (i.e., the full training set minus the validation set), and you select the model that performs best on the validation set.
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Hyperparameter Tuning and Model Selection > Position 1131
</div>
<div class="noteText">
    One way to solve this problem is to perform repeated cross-validation, using many small validation sets.
</div><div class="noteHeading">
    Notiz - Hyperparameter Tuning and Model Selection > Position 1131
</div>
<div class="noteText">
    Das Problem ist, das optimale Verhältnis von validation set und training set zu finden, was möglich ist, indem ganz viele kleine validation sets genommen werden und dann Cross validiert werden, 
</div><div class="noteHeading">
    Markierung(<span class="highlight_blue">blau</span>) - Data Mismatch > Position 1142
</div>
<div class="noteText">
    In this case, the most important rule to remember is that both the validation set and the test set must be as representative as possible of the data you expect to use in production,
</div>
        </div>
    </body>
</html>